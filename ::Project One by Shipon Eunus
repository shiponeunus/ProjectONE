//Project One by Shipon Eunus
var a, b, c, d, e, f, v, k, l;
var h= 0;
var r= random(100, 255);
var g= random(100, 255);
var n= random(100, 255);
var beginning;
var o;
var p;
var u;
var hor;
var vert; 
var next;
var after;

//arrays used in class Lines functions
let numbers= [100, 50, 150, 40, 700];
let integers= [580, 750, 135, 375, 80];

function setup() {
  createCanvas( 800, 800);
  o = new Object( 20, 28);
  p = new Object( 200, 23);
  u = new Object( 100, 20 );
  hor = new Lines();
  vert = new Lines(); 
}
  //starts off with first function that is a triangle with varying line lengths and ellipse dimensions
function beginning_(){
  strokeWeight(4);
 
  fill(255, 0, 0);
  triangle( 400, 400, 30, 795, 770, 795);
  for ( var i=0; i<100; i++) {
    a = random(80, 750);
    b = random(50, 680);
    c = random(20, 100);
    d = random(50, 110);
    //stroke(#FFCF05); 
    stroke (30, 50, 60);
    line(400, 400, a, b); 
    //stroke(#AFFFAF); 
    stroke( 40, 20, 70);
    line( 400, 390, a +30, b/2);
    //fill(#041170); 
    fill(0, 0, 230);
    ellipse( 400, 400, c, d );
  }
  //stroke(#6384EB); 
  stroke(0,0, 240);
  //fill(#3EFF05); 
  fill(0, 200, 0);
  quad(380, 385, 420, 385, 380, 415, 420, 415);
  //stroke(#FFCF05);
  stroke( 30, 50, 60);
}
// creates a puddle effect based on user interaction
function next_() { 
  background(0);
  for ( var i= 0; i < 100; i++) {
    //stroke(#CF3046); 
    stroke(200, 0, 0);
    fill(0);
    e = random(20, 950);
    f = random(30, 350);
    v= random(30, 80);
    circle( 400, 400, e);
    circle( 400, 400, e+100);
    //stroke(#EB6916); 
    stroke(150, 50, 0);

    circle( mouseX, mouseY, f);
    circle( mouseX +350, mouseY-350, f+40);
    circle(mouseX-350, mouseY-350, g);
  }

  //stroke(#91E6FF);
  stroke( 0, 0, 170);
  //fill(#8C31FF); 
  fill(200, 0, 200);
  quad( 380, 385, 420, 385, 380, 415, 420, 415);
}
// overlay of light beams on beginning_ function
function following_(x,y) {
  
  //stroke(#D322EB);
  stroke(100, 100, 100);
  //fill(#BFFCFF);
  fill(0, 0, 100);
  triangle(x, y, x +50, y+100, 400, 400);
  quad(x- 150, y-50, x -150, y-150, 385, 395, 385, 405);
  quad( x+150, y+50, y+150, y+150, 395, 395, 395, 405);
  quad( x+450, y+350, y+450, y+350, 395, 395, 395, 405);
  quad( 400, 400, 400, 450, 800- x, y+300, 800- x, y);
  //stroke(#30C6CF);
  stroke(0, 0, 48);
  //fill(#E8EB87);
  fill(50, 80, 100);
  quad( 380, 385, 420, 385, 380, 415, 420, 415);
}
//function creates a room that changes based on mouse interation
function after_() {
  background(0);

 // stroke(#46D14A);
 stroke(0, 120, 0);
  line(350, 500, 350, 250);
  line(450, 500, 450, 250);
  line( 350, 500, 450, 500);
  line( 350, 250, 0, 0);
  line(450, 250, 800, 0);
  line( 350, 500, 0, 800);
  line(350, 250, 450, 250);
  line( 450, 500, 800, 800);

  if ( mouseY+50 <= 800 && mouseY-80 >= 500) {
    var x=0; 
    var y= 0;
    for ( var i=0; i<100; i++) {

      strokeWeight(3);
      stroke( 0, 30, 140);
      //stroke(#23FFEB); 
      line( x, 500, 350+x, 800); //vertical line
      line(300-x, 550+y, 400+x, 550); // horizontal line
      x += 20;
      y+= 20;
      k= random(-50, 100);
      l = random( 25, 60);
      //fill(#EB213E);
      stroke( 200, 30, 10);
      circle( 400 + k, 600+k, l);

      strokeWeight(3);
      //stroke(#3E2DED);
      stroke(50, 50, 60);
      //fill(#A1D1C8);
      fill(150, 150, 160);
      quad(450, 500, 450, 250, 800, 0, 800, 800);
      quad(350, 500, 0, 800, 0, 0, 350, 250);
      quad( 0, 0, 800, 0, 500, 275, 300, 250);
    }
  } 
  if (mouseX -50 >=0 && mouseX<= 300 ) {
    //fill(#A1D16D);
    fill(70, 150, 24);
    quad(350, 500, 0, 800, 0, 0, 350, 250);
    quad(450, 500, 450, 250, 800, 0, 800, 800);
   // stroke(#FFE100);
    stroke( 205, 209, 30);
    fill(0);
    ellipse(mouseX+10, mouseY-30, 50, 100);
    ellipse( mouseX+10, mouseY- 30, 45, 90);
    ellipse(mouseX+ 500, mouseY-30, 50, 100);
    ellipse(mouseX+500, mouseY-30, 45, 90);
  } 
  if ( mouseX-50 >= 400 && mouseX <=800) {
    //fill(#FFB366);
    fill( 30, 130, 230);
    quad(350, 500, 0, 800, 0, 0, 350, 250);
    quad(450, 500, 450, 250, 800, 0, 800, 800);
   // stroke(#FFE100);
    stroke( 120, 70, 85);
    fill(0);
    ellipse(mouseX+60, mouseY-30, 50, 100);
    ellipse( mouseX+60, mouseY- 30, 45, 90);
    ellipse(mouseX- 500, mouseY-30, 50, 100);
    ellipse(mouseX-500, mouseY-30, 45, 90);
  }
  if ( mouseY-30 <=250 && mouseY-30 >= 0) {
    strokeWeight(3);
   // stroke(#3422EB);
    stroke( 12, 13, 14);
   // fill(#66FF7D);
    fill(230, 0, 45);
    quad( 380, 385, 420, 385, 380, 415, 420, 415);
    strokeWeight(2);
    stroke(0);
    //fill(#FFF4AE);
    fill( 45, 90, 135);
    circle( mouseX+50, mouseY-30, 15);
  //  stroke(#E52BFF);
    stroke( 200, 200, 208);
  //  fill(#00EEFF);
    fill( 0, 48, 12);
    quad( 0, 0, 800, 0, 450, 250, 350, 250);
    for (var q = 0; q < 100; q++) {

      stroke(0, g, n);
      rotate(0.1);
      scale(1.01);
      line(200, -150, 50, 150);
    //  stroke(#CA59FF);
      stroke( 30, 190, 90);
      var m = random(20); 
      rotate(PI/m);
      scale(1.05);
      line(150, 150, 90, 250);
   //   stroke(#3DFF00);
      stroke( 150, 15 ,0);
      var s = random(30); 
      rotate(PI/s);
      scale(1.01);
      line(150, 150, 90, 150);
    }
  }
  strokeWeight(3);
//  stroke(#3422EB);
  stroke( 70, 255, 40);
 // fill(#FF47AF);
  fill(  12, 138, 210);
  quad( 380, 385, 420, 385, 380, 415, 420, 415);

  strokeWeight(2);
  stroke(0);
 // fill(#FFF4AE);
  fill(36, 72, 144);
  circle(pmouseX+50, pmouseY-30, 14);
  circle( mouseX+50, mouseY-30, 15);
}
// creates line, triangle , circle , rectangle that moves with time
class Object {
  constructor (y,s) {
    this.ypos = y;
    this.speed = s;
  }

   then_() {
    //fill( #E52B79);
     fill( 126, 39, 79);
    this.ypos += speed; 
    if ( mouseX  <=750) {
      quad(mouseX-25, mouseY-25, mouseX+25, mouseY-25, mouseX-25, mouseY+25, mouseX+25, mouseY+25);
    }
    circle( 100, this.ypos -20, 25);
    triangle(200, this.ypos, 350, this.ypos, 275, ypos/2);
    rect( 600, this.ypos, width/4, this.ypos/3);
    line(0, this.ypos, width, this.ypos);
    if (this.ypos > height) { 
      this.ypos = 0;
    }
  }
}

//creates horizontal and vertical lines based on values from arrays
class Lines {
  constructor( ) {
    for (var i=0; i<5; i++) {
      this.xpos = numbers[i];
      this.ypos = integers[i];
      i++;
    }
  
  }
   subsequently_() {
    //square(mouseX, mouseY, 15);
    for (var i=0; i<5; i++) {
      this.xpos = numbers[i];
    //  stroke(#4166FF);
      stroke(50, 180, 220);
      strokeWeight(2);
      line( this.xpos, 0, this.xpos, height);
      strokeWeight(3);
      line( this.xpos+4, 0, this.xpos+4, height);
      strokeWeight(5);
      line(this.xpos+10, 0, this.xpos+10, height);
    }
  }
   succeeding_() {
    for (var i=0; i<5; i++) {
      this.ypos = integers[i];
      strokeWeight(2);
      line( 0, this.ypos, width, this.xpos);
      strokeWeight(1);
      line( 0, this.ypos+5, width, this.ypos+ 5);
      strokeWeight(3);
      line( 0, this.ypos+8, width, this.ypos+8);
    }
  }
}
// goes through different functions based on key input
function draw() {

  background(0,0,200);
  beginning_();
  if (keyIsPressed) {
    if ( key == 's') {
      next_();
    } else if ( key == 'a') {
      following_(mouseX, mouseY);
    } else if ( key == 'd') {
      after_();
    } else if ( key == 'f') {
      background(0);
      o.then_();
      p.then_();
      u.then_();
    } else if ( key == 'g') {
      background(255);
     // stroke(#E84E64);
      stroke( 180, 180, 50);
      //fill(#FFA550);
      fill( 160,30, 50);
      push();
      rotate(19);
      rect(pmouseX, pmouseY, 30, 30);
      rect(pmouseX-20, pmouseY-20, 20, 20);
      rect(mouseX-20, mouseY-30, 40, 40);
      pop();
      var i=0;
      while ( i<=300) {
        rect(pmouseX- i, pmouseY-i, 30, 30);
        rect(pmouseX+ i, pmouseY-i, 30, 30);
        i+=20;
      }
      rect(mouseX, mouseY, 50, 50);
      vert.subsequently_();
      hor.succeeding_();
    }
  }
}



